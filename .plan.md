# Implementation Plan: FABER Run ID System and Event Logging (Issue #220)

## Executive Summary

This plan implements SPEC-00108 to add a comprehensive Run ID system and event logging infrastructure to FABER. The implementation transforms FABER from per-work-item state tracking to per-run isolated execution with full event history, enabling resume, re-run, and future Helm integration.

## Current State Analysis

### What Exists Today

1. **State Management**: Single `state.json` at `.fractary/plugins/faber/state.json`
   - Tracks current phase, steps, artifacts
   - No run isolation - multiple runs overwrite same file
   - Resume is limited to work_id level, not step level

2. **Event Logging**: Via `fractary-logs` plugin
   - `workflow-event-emitter` skill emits events
   - Workflow log type with ~17 event types
   - Writes to `.fractary/logs/workflow/`
   - No run_id concept in events

3. **Entry Points**:
   - `/fractary-faber:run` → faber-director → faber-manager
   - No `--resume` or `--rerun` flags

4. **Scripts**: State management scripts in `plugins/faber/skills/core/scripts/`
   - `state-init.sh`, `state-read.sh`, `state-write.sh`, etc.
   - All operate on single state file

### Gap Analysis

| Capability | Current | Target (SPEC-00108) |
|------------|---------|---------------------|
| Run Identification | work_id only | `{org}/{project}/{uuid}` |
| File Isolation | Shared state.json | Per-run directory tree |
| Event Logging | Via fractary-logs | Local + S3 + Gateway |
| Event Types | ~17 | 25+ with richer schema |
| Resume | Work-id level | Step-level from specific run |
| Re-run | Not supported | With parameter changes |
| S3 Archive | Via logs plugin | Native consolidation |
| Helm Integration | None | Gateway foundation |

## Implementation Strategy

### Phased Approach

The spec defines 8 phases. I'll organize implementation into 4 logical phases for efficiency:

```
Phase A: Foundation (Spec Phases 1-2)
├── Run ID generation
├── Per-run directory structure
├── State migration to run-based paths
└── Event schema and file format

Phase B: Event Infrastructure (Spec Phase 3)
├── Event builder utility
├── MCP Event Gateway server
├── Local files backend
└── Backend abstraction

Phase C: Resume & Re-run (Spec Phases 4, 6)
├── --resume flag and logic
├── State reconstruction
├── --rerun flag and logic
└── Parameter diffing

Phase D: Cloud & Future (Spec Phases 5, 7-8)
├── S3 archive backend
├── Consolidation process
├── Helm integration skeleton
└── Migration guide
```

---

## Detailed Implementation Plan

### Phase A: Foundation

#### A1. Run ID Generation System

**Files to create:**

1. `plugins/faber/skills/run-manager/SKILL.md`
   - New skill for run lifecycle management
   - Operations: generate-id, init-run, get-run, list-runs

2. `plugins/faber/skills/run-manager/scripts/generate-run-id.sh`
   - Generate UUID v4 with org/project prefix
   - Format: `{org}/{project}/{uuid}`
   - Validation regex

3. `plugins/faber/skills/run-manager/scripts/init-run-directory.sh`
   - Create `.fractary/plugins/faber/runs/{org}/{project}/{uuid}/`
   - Initialize state.json, metadata.json, events/ directory

**Integration points:**
- faber-director: Generate run_id before invoking faber-manager
- faber-manager: Pass run_id to all phase skills

#### A2. Per-Run Directory Structure

**New directory structure:**
```
.fractary/plugins/faber/
├── config.json                 # Global config (unchanged)
├── gateway.json                # NEW: Event gateway config
├── workflows/                  # Workflow definitions (unchanged)
└── runs/                       # NEW: Per-run storage
    └── {org}/
        └── {project}/
            └── {uuid}/
                ├── state.json         # Run-specific state
                ├── metadata.json      # Run metadata
                └── events/
                    ├── .next-id       # Sequence counter
                    ├── 001-workflow_start.json
                    ├── 002-phase_start.json
                    └── ...
```

**Files to modify:**

1. `plugins/faber/skills/faber-state/SKILL.md`
   - Add `run_id` parameter to all operations
   - State path becomes: `.fractary/plugins/faber/runs/{run_id}/state.json`
   - Backward compatibility: If no run_id, use legacy path

2. `plugins/faber/skills/core/scripts/state-*.sh`
   - All scripts accept optional `--run-id` flag
   - Compute state path from run_id if provided

#### A3. Event Schema Definition

**Files to create:**

1. `plugins/faber/schemas/event.schema.json`
   - JSON Schema for all event types
   - Base fields: event_id, type, timestamp, run_id, phase, step, user, source, status

2. `plugins/faber/schemas/event-types/`
   - One file per event type with specific metadata schema
   - workflow_start.json, phase_start.json, step_complete.json, etc.

**Event types to implement (from spec):**
- Workflow: workflow_start, workflow_complete, workflow_error, workflow_cancelled, workflow_resumed, workflow_rerun
- Phase: phase_start, phase_skip, phase_complete, phase_error
- Step: step_start, step_complete, step_error, step_retry
- Artifacts: artifact_create, artifact_modify
- Git: commit_create, branch_create, pr_create, pr_merge
- Spec: spec_generate, spec_validate
- Test: test_run
- Docs: docs_update
- Other: checkpoint, skill_invoke, agent_invoke, decision_point, retry_loop_enter, retry_loop_exit

#### A4. State Schema Update

**Files to modify:**

1. `plugins/faber/skills/faber-state/SKILL.md`
   - Update STATE_STRUCTURE with new fields:
     - `run_id`: Full run identifier
     - `last_event_id`: For consistency
     - `work_type`: Work classification (moved from phases.frame)

2. `plugins/faber/skills/core/scripts/state-init.sh`
   - Accept run_id parameter
   - Initialize state with workflow_version: "2.1"
   - Create in run-specific directory

---

### Phase B: Event Infrastructure

#### B1. Event Builder Utility

**Files to create:**

1. `plugins/faber/skills/run-manager/scripts/emit-event.sh`
   ```bash
   # Usage: emit-event.sh --run-id <id> --type <type> --data <json>
   # - Generates next event_id from .next-id
   # - Constructs full event with automatic fields
   # - Writes to events/{seq}-{type}.json
   # - Updates state.last_event_id
   ```

2. `plugins/faber/skills/run-manager/scripts/validate-event.sh`
   - Validate event against schema
   - Check required fields
   - Validate event type

#### B2. MCP Event Gateway

**Architecture decision:** Full MCP server implementation for better abstraction and future extensibility.

**Files to create:**

1. `plugins/faber/mcp-server/`
   - Full MCP server for event routing
   - Node.js or Python implementation
   - Unix socket or TCP listener

2. `plugins/faber/mcp-server/src/server.ts` (or .py)
   - MCP server entry point
   - Event validation
   - Backend routing
   - Sequence number management

3. `plugins/faber/mcp-server/src/backends/local-files.ts`
   - Write events to per-run directory
   - Sync to disk (fsync if configured)
   - Update event index

4. `plugins/faber/mcp-server/src/backends/s3-archive.ts`
   - S3 upload capability
   - Consolidation logic
   - Lifecycle management

5. `plugins/faber/mcp-server/package.json` (or requirements.txt)
   - Dependencies for MCP server

6. `plugins/faber/gateway/config.template.json`
   - Template for gateway.json configuration
   - Backends: local_files (enabled), s3_archive (configurable)

**MCP Resources:**
- `faber://event/emit` - Send event to gateway
- `faber://run/{run_id}/state` - Get run state
- `faber://run/{run_id}/events` - Query events
- `faber://runs/list` - List runs for project

#### B3. Emit Events in Workflow

**Files to modify:**

1. `plugins/faber/agents/faber-manager.md`
   - Add run_id to workflow context
   - Emit events at key points:
     - workflow_start (after init)
     - phase_start (before phase)
     - step_start/complete (around steps)
     - phase_complete (after phase)
     - workflow_complete (at end)

2. `plugins/faber/skills/faber-director/SKILL.md`
   - Generate run_id in Step 0.5 (after config load, before issue fetch)
   - Pass run_id to faber-manager
   - Emit workflow_start event

---

### Phase C: Resume & Re-run

#### C1. Resume Capability

**Files to modify:**

1. `plugins/faber/commands/run.md`
   - Add `--resume <run_id>` option
   - Mutually exclusive with `--rerun`

2. `plugins/faber/skills/faber-director/SKILL.md`
   - Handle resume flag:
     - Load state from specified run
     - Determine next step to execute
     - Emit workflow_resumed event
   - Pass resume context to faber-manager

3. `plugins/faber/agents/faber-manager.md`
   - Handle resume mode:
     - Skip completed phases/steps
     - Start from failed/incomplete step
     - Preserve original run_id

**Files to create:**

1. `plugins/faber/skills/run-manager/scripts/resume-run.sh`
   - Load state for run_id
   - Validate run is resumable (not completed, not archived)
   - Calculate next phase/step
   - Return resume context

2. `plugins/faber/skills/run-manager/scripts/reconstruct-state.sh`
   - Rebuild state.json from events
   - Used for corruption recovery
   - Compare reconstructed vs stored

#### C2. Re-run Capability

**Files to modify:**

1. `plugins/faber/commands/run.md`
   - Add `--rerun <run_id>` option
   - Allows additional parameter overrides

2. `plugins/faber/skills/faber-director/SKILL.md`
   - Handle rerun flag:
     - Load original run metadata
     - Generate new run_id
     - Merge parameter changes
     - Emit workflow_rerun event

**Files to create:**

1. `plugins/faber/skills/run-manager/scripts/rerun-run.sh`
   - Load original run metadata
   - Generate new run_id
   - Create relationship record
   - Return rerun context

---

### Phase D: Cloud & Future

#### D1. S3 Archive Backend

**Files to create:**

1. `plugins/faber/gateway/backends/s3-archive.sh`
   - Upload events to S3
   - Consolidate to events.jsonl
   - Update archive index

2. `plugins/faber/skills/run-manager/scripts/consolidate-events.sh`
   - Collect all events from run
   - Sort by event_id
   - Write as JSONL
   - Upload to S3

3. `plugins/faber/skills/run-manager/scripts/cleanup-local.sh`
   - Remove local event files after successful archive
   - Keep state.json and metadata.json
   - Configurable retention

**S3 Path Structure:**
```
s3://fractary-workflow-logs/
└── faber/runs/{org}/{project}/{uuid}/
    ├── state.json
    ├── metadata.json
    └── events.jsonl
```

#### D2. Helm Integration Foundation

**DEFERRED** - Per user decision, Helm integration will be implemented when Helm is being built. The MCP server architecture is designed to support adding an event-stream backend later without changes to event producers.

#### D3. Documentation & Config Updates

**Migration approach:** No backward compatibility needed. The `/fractary-faber:init` command will be updated to always ensure config is current (overwrite old config instead of erroring if exists).

**Files to create:**

1. `plugins/faber/docs/RUN-ID-SYSTEM.md`
   - Complete documentation of run ID system
   - Usage examples
   - Troubleshooting

**Files to modify:**

1. `plugins/faber/commands/init.md`
   - Update to overwrite existing config instead of erroring
   - Ensure gateway.json is created
   - Initialize runs/ directory structure

2. `plugins/faber/README.md`
   - Update with run ID system
   - New commands and flags

---

## File Summary

### New Files (~25 files)

| Path | Purpose |
|------|---------|
| `skills/run-manager/SKILL.md` | Run lifecycle management skill |
| `skills/run-manager/scripts/generate-run-id.sh` | UUID generation |
| `skills/run-manager/scripts/init-run-directory.sh` | Directory setup |
| `skills/run-manager/scripts/emit-event.sh` | Event emission (calls MCP) |
| `skills/run-manager/scripts/validate-event.sh` | Event validation |
| `skills/run-manager/scripts/resume-run.sh` | Resume logic |
| `skills/run-manager/scripts/reconstruct-state.sh` | State from events |
| `skills/run-manager/scripts/rerun-run.sh` | Re-run logic |
| `skills/run-manager/scripts/consolidate-events.sh` | JSONL consolidation |
| `skills/run-manager/scripts/cleanup-local.sh` | Local cleanup |
| `mcp-server/src/server.ts` | MCP server entry point |
| `mcp-server/src/backends/local-files.ts` | Local backend |
| `mcp-server/src/backends/s3-archive.ts` | S3 backend |
| `mcp-server/src/schemas/event.ts` | Event types |
| `mcp-server/package.json` | Dependencies |
| `mcp-server/tsconfig.json` | TypeScript config |
| `gateway/config.template.json` | Gateway config |
| `schemas/event.schema.json` | Event schema |
| `schemas/event-types/*.json` | Type-specific schemas |
| `docs/RUN-ID-SYSTEM.md` | System documentation |

### Modified Files (9 files)

| Path | Changes |
|------|---------|
| `commands/run.md` | Add --resume and --rerun flags |
| `commands/init.md` | Overwrite existing config, create gateway.json |
| `skills/faber-director/SKILL.md` | Run ID generation, resume/rerun handling |
| `agents/faber-manager.md` | Event emission, run_id context |
| `skills/faber-state/SKILL.md` | Run-based paths |
| `skills/core/scripts/state-init.sh` | Run ID parameter |
| `skills/core/scripts/state-read.sh` | Run ID parameter |
| `skills/core/scripts/state-write.sh` | Run ID parameter |
| `README.md` | Documentation updates |

---

## Execution Order

### Step 1: Foundation Scripts (can be done in parallel)
- [ ] Create `generate-run-id.sh`
- [ ] Create `init-run-directory.sh`
- [ ] Create event schema files

### Step 2: State System Updates
- [ ] Update `faber-state/SKILL.md` with run_id support
- [ ] Update `state-*.sh` scripts with --run-id flag
- [ ] Test backward compatibility

### Step 3: Run Manager Skill
- [ ] Create `run-manager/SKILL.md`
- [ ] Create remaining run-manager scripts
- [ ] Test run lifecycle

### Step 4: Event Infrastructure
- [ ] Create gateway scripts
- [ ] Create local-files backend
- [ ] Create emit-event.sh
- [ ] Test event flow

### Step 5: Workflow Integration
- [ ] Update faber-director with run_id generation
- [ ] Update faber-manager with event emission
- [ ] Test full workflow with events

### Step 6: Resume Capability
- [ ] Add --resume to run command
- [ ] Implement resume logic in director
- [ ] Implement skip logic in manager
- [ ] Test resume scenarios

### Step 7: Re-run Capability
- [ ] Add --rerun to run command
- [ ] Implement rerun logic
- [ ] Test rerun scenarios

### Step 8: S3 & Documentation
- [ ] Create S3 backend (can be deferred)
- [ ] Create Helm skeleton (can be deferred)
- [ ] Write migration guide
- [ ] Update README

---

## Risk Mitigation

### Implementation Risks
- **MCP Server Complexity**: Using TypeScript with well-tested MCP SDK mitigates risk
- **Event Loss**: Local files backend writes synchronously before returning success
- **S3 Failures**: Local events retained until successful S3 upload

### Rollback Strategy
- Feature flags in gateway.json
- Can disable event logging without breaking workflow
- MCP server can be bypassed if issues arise

### Testing Strategy
- Unit tests for each script
- Integration tests for run lifecycle
- End-to-end test: full workflow with resume
- MCP server unit tests

---

## Success Criteria

1. **Run ID Generation**: Every workflow run gets unique, traceable ID
2. **Per-Run Isolation**: Parallel runs don't conflict
3. **Event Logging**: All 25+ event types recorded
4. **MCP Server**: Running and accepting events
5. **Resume Works**: Can resume from failed step
6. **Re-run Works**: Can re-run with different params
7. **Documentation**: Complete guide for users

---

## Dependencies

- `jq` - JSON processing (already required)
- `uuidgen` or Python - UUID generation (fallback available)
- Node.js 18+ - For MCP server
- `@anthropic/mcp-sdk` - MCP server SDK
- AWS CLI - For S3 backend (optional)

---

## Estimated Effort

| Phase | Components | Effort |
|-------|------------|--------|
| A | Foundation | 4-6 files, ~500 LoC |
| B | Event Infrastructure + MCP | 10-12 files, ~800 LoC |
| C | Resume & Re-run | 4-6 files, ~300 LoC |
| D | S3 & Docs | 3-4 files, ~200 LoC + docs |
| **Total** | | **~25 files, ~1800 LoC** |

---

## Design Decisions (User Input)

1. **MCP Server**: Full MCP server implementation (not script-based)
2. **Migration**: No backward compatibility needed - `/fractary-faber:init` will overwrite existing config
3. **Helm Integration**: Deferred until Helm is being built
