name: Sync Project Docs into Codex

on:
  workflow_dispatch:
    inputs:
      target_repository:
        description: 'Specific repository to sync (optional, syncs all if empty)'
        required: false
        type: string
  repository_dispatch:
    types: [sync-from-project]
  # NOTE: Automatic triggers have been disabled
  # Uncomment the section below to re-enable automatic syncing:
  
  # schedule:
  #   - cron: '0 */3 * * *'  # Every 3 hours

# Configuration variables for template reuse
env:
  ORGANIZATION_NAME: "corthosai"
  CODEX_REPO_NAME: "codex.corthos.ai"
  TARGET_DIRECTORY: "systems"
  PAT_SECRET_NAME: "CODEX_SYNC_PAT"
  SYNC_SCHEDULE_HOURS: "3"  # Run every N hours
  BOT_NAME: "Codex Sync Bot"
  BOT_EMAIL: "codex-sync-bot@corthos.ai"
  # Safety controls for file deletion
  DRY_RUN: "false"  # Set to "true" to preview changes without applying
  MAX_DELETION_THRESHOLD: "50"  # Maximum files to delete in one run

jobs:
  get-repos:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Get organization repositories
        id: set-matrix
        env:
          GH_TOKEN: ${{ secrets[env.PAT_SECRET_NAME] }}
        run: |
          # Check if we're syncing a specific repository (from dispatch event or workflow input)
          TARGET_REPO="${{ github.event.client_payload.repository }}${{ github.event.inputs.target_repository }}"
          
          if [ -n "$TARGET_REPO" ]; then
            echo "Syncing specific repository: $TARGET_REPO"
            # Create matrix with single repository
            MATRIX_JSON='{"include":[{"repo":"'$TARGET_REPO'"}]}'
            echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Otherwise, sync all repositories
          # Define repos to exclude from sync (never sync from these)
          EXCLUDE_REPOS='["${{ env.CODEX_REPO_NAME }}"]'
          
          # Get all repos in the organization using direct API call with curl
          echo "Fetching repositories from ${{ env.ORGANIZATION_NAME }} organization..."
          
          # First get the raw API response
          API_RESPONSE=$(curl -s -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/orgs/${{ env.ORGANIZATION_NAME }}/repos?per_page=100")
          
          echo "API Response: $API_RESPONSE"
          
          # Check if it's a valid JSON array
          if ! echo "$API_RESPONSE" | jq empty 2>/dev/null; then
            echo "ERROR: Invalid JSON response from GitHub API"
            exit 1
          fi
          
          # Check if it's an error response
          if echo "$API_RESPONSE" | jq -e '.message' > /dev/null 2>&1; then
            ERROR_MSG=$(echo "$API_RESPONSE" | jq -r '.message')
            echo "ERROR: GitHub API returned error: $ERROR_MSG"
            exit 1
          fi
          
          # Extract repository names
          ALL_REPOS=$(echo "$API_RESPONSE" | jq -r '.[].name')
          echo "Found repositories: $ALL_REPOS"
          
          # Convert to JSON array
          ALL_REPOS_JSON=$(echo "$ALL_REPOS" | jq -R . | jq -s .)
          echo "Raw repo list: $ALL_REPOS_JSON"
          
          # Filter out excluded repos
          FILTERED_REPOS=$(echo "$ALL_REPOS_JSON" | jq --argjson exclude "$EXCLUDE_REPOS" '. - $exclude')
          echo "Filtered repos: $FILTERED_REPOS"
          
          # Check if we have any repos to sync
          REPO_COUNT=$(echo "$FILTERED_REPOS" | jq 'length')
          echo "Found $REPO_COUNT repositories to sync from"
          
          if [ "$REPO_COUNT" -eq 0 ]; then
            echo "No repositories found to sync from. Setting empty matrix."
            echo "matrix={\"include\":[]}" >> $GITHUB_OUTPUT
          else
            # Set the matrix output - GitHub Actions expects {include: [{repo: "name1"}, {repo: "name2"}]}
            MATRIX_JSON=$(echo "$FILTERED_REPOS" | jq -c 'map({repo: .}) | {include: .}')
            echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT
            echo "Available repos for syncing docs: $(echo "$FILTERED_REPOS" | jq -r '. | join(", ")')"
          fi

  sync-docs:
    needs: get-repos
    runs-on: ubuntu-latest
    permissions:
      contents: write
    if: ${{ fromJson(needs.get-repos.outputs.matrix).include[0] != null }}
    strategy:
      matrix: ${{fromJson(needs.get-repos.outputs.matrix)}}
      fail-fast: false  # Continue with other repos even if one fails
    steps:
      - name: Checkout codex repo
        uses: actions/checkout@v3

      - name: Check if source repo exists and accessible
        id: check-repo
        env:
          GH_TOKEN: ${{ secrets.CODEX_SYNC_PAT }}
        run: |
          # Check if we can access the repository
          if gh api repos/${{ env.ORGANIZATION_NAME }}/${{ matrix.repo }} >/dev/null 2>&1; then
            echo "repo_exists=true" >> $GITHUB_OUTPUT
            echo "✅ Repository ${{ matrix.repo }} is accessible"
          else
            echo "repo_exists=false" >> $GITHUB_OUTPUT
            echo "❌ Repository ${{ matrix.repo }} is not accessible or doesn't exist"
            echo "::warning::Cannot access repository ${{ matrix.repo }}. It may not exist or the PAT may lack permissions."
          fi

      - name: Get default branch for repository
        if: steps.check-repo.outputs.repo_exists == 'true'
        id: get-branch
        env:
          GH_TOKEN: ${{ secrets[env.PAT_SECRET_NAME] }}
        run: |
          # Get the default branch name
          DEFAULT_BRANCH=$(curl -s -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ env.ORGANIZATION_NAME }}/${{ matrix.repo }}" | \
            jq -r '.default_branch')
          
          echo "Default branch for ${{ matrix.repo }}: $DEFAULT_BRANCH"
          echo "default_branch=$DEFAULT_BRANCH" >> $GITHUB_OUTPUT

      - name: Checkout project repository
        if: steps.check-repo.outputs.repo_exists == 'true' && steps.get-branch.outputs.default_branch != 'null' && steps.get-branch.outputs.default_branch != ''
        continue-on-error: true
        id: checkout-repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.ORGANIZATION_NAME }}/${{ matrix.repo }}
          token: ${{ secrets[env.PAT_SECRET_NAME] }}
          ref: ${{ steps.get-branch.outputs.default_branch }}
          sparse-checkout: |
            docs
            CLAUDE.md
            README.md
          sparse-checkout-cone-mode: false
          path: temp_repo

      - name: Check if checkout succeeded
        if: steps.check-repo.outputs.repo_exists == 'true'
        id: verify-checkout
        run: |
          if [ "${{ steps.checkout-repo.outcome }}" = "success" ] && [ -d "temp_repo" ]; then
            echo "checkout_success=true" >> $GITHUB_OUTPUT
            echo "✅ Successfully checked out ${{ matrix.repo }}"
          else
            echo "checkout_success=false" >> $GITHUB_OUTPUT
            echo "⚠️ Failed to checkout ${{ matrix.repo }} (likely empty repository or no content)"
          fi

      - name: Copy docs to systems directory
        if: steps.verify-checkout.outputs.checkout_success == 'true'
        run: |
          # Create target directory
          mkdir -p ${{ env.TARGET_DIRECTORY }}/${{ matrix.repo }}/docs
          
          # Check if temp_repo was actually checked out
          if [ ! -d "temp_repo" ]; then
            echo "⚠️ Repository checkout failed for ${{ matrix.repo }}, skipping..."
            exit 0
          fi
          
          # Step 1: Create manifest of source files
          echo "Creating source manifest..."
          > /tmp/source_manifest.txt
          
          # Add docs files to manifest
          if [ -d "temp_repo/docs" ]; then
            find temp_repo/docs -type f 2>/dev/null | while read -r file; do
              echo "${file#temp_repo/}" >> /tmp/source_manifest.txt
            done
          fi
          
          # Add individual files to manifest
          [ -f "temp_repo/CLAUDE.md" ] && echo "CLAUDE.md" >> /tmp/source_manifest.txt
          [ -f "temp_repo/README.md" ] && echo "README.md" >> /tmp/source_manifest.txt
          
          # Step 2: Create manifest of existing target files
          echo "Creating target manifest..."
          > /tmp/target_manifest.txt
          if [ -d "${{ env.TARGET_DIRECTORY }}/${{ matrix.repo }}" ]; then
            find ${{ env.TARGET_DIRECTORY }}/${{ matrix.repo }} -type f 2>/dev/null | while read -r file; do
              echo "${file#${{ env.TARGET_DIRECTORY }}/${{ matrix.repo }}/}" >> /tmp/target_manifest.txt
            done
          fi
          
          # Step 3: Identify orphaned files (in target but not in source)
          echo "Identifying orphaned files..."
          comm -13 <(sort /tmp/source_manifest.txt) <(sort /tmp/target_manifest.txt) > /tmp/orphaned_files.txt || true
          
          # Step 4: Remove orphaned files with safety check
          orphaned_count=$(wc -l < /tmp/orphaned_files.txt)
          if [ $orphaned_count -gt 0 ]; then
            echo "Found $orphaned_count orphaned files"
            
            # Safety check: Don't delete too many files at once
            if [ $orphaned_count -gt ${{ env.MAX_DELETION_THRESHOLD }} ]; then
              echo "⚠️ WARNING: Would delete $orphaned_count files, which exceeds safety threshold of ${{ env.MAX_DELETION_THRESHOLD }}"
              echo "Orphaned files that would be deleted:"
              cat /tmp/orphaned_files.txt
              echo "Skipping deletion for safety. Manual review required."
            else
              if [ "${{ env.DRY_RUN }}" = "true" ]; then
                echo "DRY RUN MODE: Would remove the following orphaned files:"
                while IFS= read -r orphaned_file; do
                  [ -z "$orphaned_file" ] && continue
                  echo "  - $orphaned_file"
                done < /tmp/orphaned_files.txt
              else
                echo "Removing orphaned files..."
                while IFS= read -r orphaned_file; do
                  [ -z "$orphaned_file" ] && continue
                  full_path="${{ env.TARGET_DIRECTORY }}/${{ matrix.repo }}/$orphaned_file"
                  if [ -f "$full_path" ]; then
                    rm "$full_path"
                    echo "  ✓ Removed: $orphaned_file"
                  fi
                done < /tmp/orphaned_files.txt
              fi
            fi
          else
            echo "No orphaned files found"
          fi
          
          # Step 5: Copy new/updated files
          # Copy docs directory if it exists
          if [ -d "temp_repo/docs" ]; then
            echo "Syncing docs directory..."
            cp -r temp_repo/docs/* ${{ env.TARGET_DIRECTORY }}/${{ matrix.repo }}/docs/ 2>/dev/null || echo "No files to copy from docs/"
          else
            echo "No docs directory found in ${{ matrix.repo }}"
          fi
          
          # Copy CLAUDE.md if it exists
          if [ -f "temp_repo/CLAUDE.md" ]; then
            echo "Copying CLAUDE.md..."
            cp temp_repo/CLAUDE.md ${{ env.TARGET_DIRECTORY }}/${{ matrix.repo }}/
          fi
          
          # Copy README.md if it exists
          if [ -f "temp_repo/README.md" ]; then
            echo "Copying README.md..."
            cp temp_repo/README.md ${{ env.TARGET_DIRECTORY }}/${{ matrix.repo }}/
          fi
          
          # Step 6: Clean up empty directories
          find ${{ env.TARGET_DIRECTORY }}/${{ matrix.repo }} -type d -empty -delete 2>/dev/null || true
          
          # Show final state
          echo ""
          echo "Final files in ${{ env.TARGET_DIRECTORY }}/${{ matrix.repo }}:"
          find ${{ env.TARGET_DIRECTORY }}/${{ matrix.repo }}/ -type f | wc -l
          ls -la ${{ env.TARGET_DIRECTORY }}/${{ matrix.repo }}/ 2>/dev/null || echo "Directory is empty"
          
          # Clean up temp directory to avoid git tracking it
          rm -rf temp_repo

      - name: Commit and push updates
        if: steps.verify-checkout.outputs.checkout_success == 'true'
        run: |
          git config user.name "${{ env.BOT_NAME }}"
          git config user.email "${{ env.BOT_EMAIL }}"
          
          # Check if the target directory exists and has content
          if [ -d "${{ env.TARGET_DIRECTORY }}" ] && [ "$(ls -A ${{ env.TARGET_DIRECTORY }})" ]; then
            # Add all changes including deletions (force to override .gitignore)
            git add -A -f ${{ env.TARGET_DIRECTORY }}
            if git diff --staged --quiet; then
              echo "No changes to commit"
            else
              # Pull latest changes before committing to avoid conflicts from parallel jobs
              git stash push -m "Temporary stash for sync from ${{ matrix.repo }}"
              git pull --rebase
              git stash pop
              
              # Re-add changes after stash pop (including deletions, force to override .gitignore)
              git add -A -f ${{ env.TARGET_DIRECTORY }}
              git commit -m "Sync docs from ${{ matrix.repo }}"
              
              # Retry push up to 3 times in case of conflicts
              for i in {1..3}; do
                if git push; then
                  echo "Successfully pushed on attempt $i"
                  break
                elif [ $i -lt 3 ]; then
                  echo "Push failed on attempt $i, pulling and retrying..."
                  git pull --rebase
                else
                  echo "Push failed after 3 attempts"
                  exit 1
                fi
              done
            fi
          else
            echo "No files found in ${{ env.TARGET_DIRECTORY }}/ to commit"
          fi
