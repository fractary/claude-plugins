name: Sync Codex Claude to Project Repos

on:
  # Allow manual triggering from GitHub Actions UI
  workflow_dispatch:
    inputs:
      target_repository:
        description: 'Specific repository to sync to (optional, syncs all if empty)'
        required: false
        type: string
  # Repository dispatch for programmatic triggering
  repository_dispatch:
    types: [sync-codex-claude-to-projects]
  # NOTE: Automatic triggers have been disabled by default
  # Uncomment the sections below to enable automatic syncing:
  
  # # Trigger when any Claude files are changed
  # push:
  #   paths:
  #     - '.claude/agents/corthos/**'
  #     - '.claude/commands/corthos/**'
  #     - '.claude/hooks/corthos/**'
  
  # # Run weekly to ensure all repos stay in sync
  # schedule:
  #   - cron: '0 6 * * 1'  # Weekly on Monday at 6AM UTC

# Configuration variables
env:
  ORGANIZATION_NAME: "corthosai"
  CODEX_REPO_NAME: "codex.corthos.ai"
  PAT_SECRET_NAME: "CODEX_SYNC_PAT"
  BOT_NAME: "Codex Sync Bot"
  BOT_EMAIL: "codex-sync-bot@corthos.ai"
  # Safety controls for file operations
  DRY_RUN: "false"  # Set to "true" to preview changes without applying
  MAX_DELETION_THRESHOLD: "50"  # Maximum files to delete in one run

jobs:
  get-repos:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Get organization repositories
        id: set-matrix
        env:
          GH_TOKEN: ${{ secrets[env.PAT_SECRET_NAME] }}
        run: |
          # Check if we're syncing to a specific repository (from workflow input)
          TARGET_REPO="${{ github.event.inputs.target_repository }}"
          
          if [ -n "$TARGET_REPO" ]; then
            echo "Syncing to specific repository: $TARGET_REPO"
            # Create matrix with single repository
            MATRIX_JSON='{"include":[{"repo":"'$TARGET_REPO'"}]}'
            echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Otherwise, sync to all repositories
          # Define repos to exclude from sync (never sync to these)
          EXCLUDE_REPOS='["${{ env.CODEX_REPO_NAME }}"]'
          
          # Get all repos in the organization using direct API call with curl
          API_RESPONSE=$(curl -s -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/orgs/${{ env.ORGANIZATION_NAME }}/repos?per_page=100")
          
          echo "API Response: $API_RESPONSE"
          
          # Check if it's an error response
          if echo "$API_RESPONSE" | jq -e '.message' > /dev/null 2>&1; then
            ERROR_MSG=$(echo "$API_RESPONSE" | jq -r '.message')
            echo "ERROR: GitHub API returned error: $ERROR_MSG"
            exit 1
          fi
          
          # Extract repository names and convert to JSON array
          ALL_REPOS=$(echo "$API_RESPONSE" | jq -r '.[].name' | jq -R . | jq -s .)
          
          # Filter out excluded repos
          FILTERED_REPOS=$(echo "$ALL_REPOS" | jq --argjson exclude "$EXCLUDE_REPOS" '. - $exclude')
          
          # Set the matrix output - GitHub Actions expects {include: [{repo: "name1"}, {repo: "name2"}]}
          MATRIX_JSON=$(echo "$FILTERED_REPOS" | jq -c 'map({repo: .}) | {include: .}')
          
          # Set the matrix output
          echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT
          
          # Debug output
          echo "Available repos for syncing from ${{ env.ORGANIZATION_NAME }}: $(echo "$FILTERED_REPOS" | jq -r '. | join(", ")')"

  sync-claude-files:
    needs: get-repos
    runs-on: ubuntu-latest
    permissions:
      contents: write
    strategy:
      matrix: ${{fromJson(needs.get-repos.outputs.matrix)}}
      fail-fast: false  # Continue with other repos even if one fails
    steps:
      - name: Checkout codex repo (current repo)
        uses: actions/checkout@v4

      - name: Check if target repo exists and accessible
        id: check-repo
        env:
          GH_TOKEN: ${{ secrets[env.PAT_SECRET_NAME] }}
        run: |
          # Check if we can access the repository using direct API call
          API_RESPONSE=$(curl -s -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ env.ORGANIZATION_NAME }}/${{ matrix.repo }}")
          
          if echo "$API_RESPONSE" | jq -e '.message' > /dev/null 2>&1; then
            echo "repo_exists=false" >> $GITHUB_OUTPUT
            echo "❌ Repository ${{ matrix.repo }} is not accessible or doesn't exist"
            echo "::warning::Cannot access repository ${{ matrix.repo }}. It may not exist or the PAT may lack permissions."
          else
            echo "repo_exists=true" >> $GITHUB_OUTPUT
            echo "✅ Repository ${{ matrix.repo }} is accessible"
          fi

      - name: Get default branch for target repository
        if: steps.check-repo.outputs.repo_exists == 'true'
        id: get-branch
        env:
          GH_TOKEN: ${{ secrets[env.PAT_SECRET_NAME] }}
        run: |
          # Get the default branch name
          DEFAULT_BRANCH=$(curl -s -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ env.ORGANIZATION_NAME }}/${{ matrix.repo }}" | \
            jq -r '.default_branch')
          
          echo "Default branch for ${{ matrix.repo }}: $DEFAULT_BRANCH"
          echo "default_branch=$DEFAULT_BRANCH" >> $GITHUB_OUTPUT

      - name: Configure Git for long filenames
        run: |
          # Configure git to handle long filenames (Windows compatibility)
          git config --global core.longpaths true

      - name: Checkout target repository
        if: steps.check-repo.outputs.repo_exists == 'true' && steps.get-branch.outputs.default_branch != 'null' && steps.get-branch.outputs.default_branch != ''
        continue-on-error: true
        id: checkout-repo
        run: |
          # Clone without checking out files first
          git clone --no-checkout https://x-access-token:${{ secrets[env.PAT_SECRET_NAME] }}@github.com/${{ env.ORGANIZATION_NAME }}/${{ matrix.repo }}.git .temp/target_repo
          cd .temp/target_repo
          
          # Configure to skip symlinks
          git config core.symlinks false
          
          # Now checkout, which will skip symlinks
          git checkout ${{ steps.get-branch.outputs.default_branch }}
          
          echo "✅ Checked out ${{ matrix.repo }} (symlinks skipped)"

      - name: Check if checkout succeeded
        if: steps.check-repo.outputs.repo_exists == 'true'
        id: verify-checkout
        run: |
          if [ "${{ steps.checkout-repo.outcome }}" = "success" ] && [ -d ".temp/target_repo" ]; then
            echo "checkout_success=true" >> $GITHUB_OUTPUT
            echo "✅ Successfully checked out ${{ matrix.repo }}"
          else
            echo "checkout_success=false" >> $GITHUB_OUTPUT
            echo "⚠️ Failed to checkout ${{ matrix.repo }} (likely empty repository or no content)"
          fi

      - name: Sync Claude files to target repository
        if: steps.verify-checkout.outputs.checkout_success == 'true'
        run: |
          # Function to extract frontmatter value
          get_frontmatter_value() {
            local file=$1
            local key=$2
            
            # First try the direct key (e.g., codex_sync_include) 
            # Check if it's an inline array format first [value1, value2]
            local value=$(tr -d '\r' < "$file" | awk '
              /^---$/ { if (++count == 1) in_fm=1; else exit }
              in_fm && /^'"$key"':[ ]*\[/ { 
                # Inline array format
                sub(/^'"$key"':[ ]*/, ""); 
                gsub(/^[ \t]*|[ \t]*$/, "");
                gsub(/^["'"'"']|["'"'"']$/, "");
                # Handle arrays in YAML (flatten to pipe-separated)
                gsub(/[\[\]"]/, "");
                gsub(/,[ ]*/, "|");
                gsub(/^[ \t]*|[ \t]*$/, "");
                print; 
                exit 
              }
            ')
            
            # If not found as inline array, try YAML list format
            if [ -z "$value" ]; then
              value=$(tr -d '\r' < "$file" | awk '
                /^---$/ { if (++count == 1) in_fm=1; else exit }
                in_fm && /^'"$key"':[ ]*$/ { 
                  # Found the key with no inline value, expect list format
                  in_list=1; next 
                }
                in_list && /^[a-zA-Z]/ && !/^[ \t]/ { 
                  # End of list, found next top-level key
                  exit 
                }
                in_list && /^[ \t]+-[ \t]*/ {
                  # List item
                  sub(/^[ \t]+-[ ]*/, "");
                  gsub(/^[ \t]*|[ \t]*$/, "");
                  gsub(/^["'"'"']|["'"'"']$/, "");
                  if (result) result = result "|" $0
                  else result = $0
                }
                END { if (result) print result }
              ')
            fi
            
            # If not found and key is codex_sync_include, try the nested codex.includes structure
            # Also handle the plural form codex_sync_includes
            if [ -z "$value" ] && ([ "$key" = "codex_sync_include" ] || [ "$key" = "codex_sync_includes" ]); then
              # IMPORTANT: Remove ALL carriage returns from the file first to handle CRLF line endings
              value=$(tr -d '\r' < "$file" | awk '
                /^---$/ { if (++count == 1) in_fm=1; else exit }
                in_fm && /^codex:/ { in_codex=1; next }
                in_codex && /^[a-zA-Z]/ && !/^[ \t]/ { in_codex=0 }
                in_codex && /^[ \t]+includes:/ { in_includes=1; next }
                in_includes && /^[ \t]+[a-zA-Z]/ && !/^[ \t]+-/ { in_includes=0 }
                in_includes && /^[ \t]+-/ {
                  sub(/^[ \t]+-[ ]*/, "");
                  gsub(/^[ \t]*|[ \t]*$/, "");
                  gsub(/^["'"'"']|["'"'"']$/, "");
                  if (result) result = result "|" $0
                  else result = $0
                }
                END { if (result) print result }
              ')
            fi
            
            echo "$value"
          }
          
          # Function to check if repo matches a pattern (supports wildcards)
          pattern_matches_repo() {
            local pattern=$1
            local repo=$2
            
            # Convert shell glob pattern to regex
            # First escape dots, then replace * with .*
            local regex_pattern=$(echo "$pattern" | sed 's/\./\\./g' | sed 's/\*/.*/g')
            
            # Check if repo matches the pattern
            if echo "$repo" | grep -q "^$regex_pattern$"; then
              return 0
            else
              return 1
            fi
          }
          
          # Function to check if repo should receive file
          should_sync_to_repo() {
            local file=$1
            local target_repo=$2

            # Shell scripts (hooks) don't have frontmatter, so sync them to all repos by default
            if [[ "$file" == *.sh ]]; then
              echo "  Shell script detected - syncing to all repos"
              return 0
            fi

            # Get include and exclude rules (try both singular and plural forms)
            local include_rule=$(get_frontmatter_value "$file" "codex_sync_include")
            if [ -z "$include_rule" ]; then
              include_rule=$(get_frontmatter_value "$file" "codex_sync_includes")
            fi

            local exclude_rule=$(get_frontmatter_value "$file" "codex_sync_exclude")
            if [ -z "$exclude_rule" ]; then
              exclude_rule=$(get_frontmatter_value "$file" "codex_sync_excludes")
            fi

            # If no include rule, skip this file
            if [ -z "$include_rule" ]; then
              return 1
            fi
            
            # Check exclude rule first (takes precedence)
            if [ -n "$exclude_rule" ]; then
              # Split exclude rule by | and check each pattern
              local excluded=0
              while IFS= read -r pattern; do
                [ -z "$pattern" ] && continue
                if pattern_matches_repo "$pattern" "$target_repo"; then
                  echo "  Excluded by codex_sync_exclude pattern: $pattern"
                  excluded=1
                  break
                fi
              done <<< "$(echo "$exclude_rule" | tr '|' '\n')"
              # If excluded, skip this repo
              if [ $excluded -eq 1 ]; then
                return 1
              fi
            fi
            
            # Check include rule
            if [ "$include_rule" = "*" ]; then
              # Include all (unless excluded above)
              return 0
            else
              # Split include rule by | and check each pattern
              local included=0
              while IFS= read -r pattern; do
                [ -z "$pattern" ] && continue
                if pattern_matches_repo "$pattern" "$target_repo"; then
                  included=1
                  break
                fi
              done <<< "$(echo "$include_rule" | tr '|' '\n')"
              # If included, sync to this repo
              if [ $included -eq 1 ]; then
                return 0
              else
                echo "  Not matching any codex_sync_include pattern: $include_rule"
                return 1
              fi
            fi
          }
          
          echo "Syncing Claude files to ${{ matrix.repo }}..."
          echo ""
          
          # Track synced files for manifest
          > /tmp/synced_files_manifest.txt
          echo "0" > /tmp/sync_count
          
          # Define source directories to sync
          CLAUDE_DIRS=".claude/agents/corthos .claude/commands/corthos .claude/hooks/corthos"
          
          for source_dir in $CLAUDE_DIRS; do
            if [ -d "$source_dir" ]; then
              echo "Checking $source_dir/ files..."
              
              # Find all markdown files in the source directory (commands and agents are .md files)
              # Also include shell scripts for hooks
              while IFS= read -r file; do
                # Get relative path from source directory
                rel_path=${file#$source_dir/}
                filename=$(basename "$file")
                
                echo -n "  $file: "
                
                # Check if this file should sync to current repo
                should_sync=0
                if should_sync_to_repo "$file" "${{ matrix.repo }}"; then
                  should_sync=1
                fi
                
                if [ $should_sync -eq 1 ]; then
                  # Create target directory if it doesn't exist
                  target_dir=".temp/target_repo/$source_dir"
                  mkdir -p "$target_dir"
                  
                  # Copy the file
                  cp "$file" "$target_dir/$rel_path"
                  echo "✅ Synced"
                  
                  # Add to manifest
                  echo "$source_dir/$rel_path" >> /tmp/synced_files_manifest.txt
                  
                  # Update count
                  count=$(cat /tmp/sync_count)
                  echo $((count + 1)) > /tmp/sync_count
                else
                  echo "⏭️  Skipped"
                fi
              done < <(find "$source_dir" -type f \( -name "*.md" -o -name "*.sh" \))
              
              echo ""
            else
              echo "⚠️ Directory $source_dir not found"
            fi
          done
          
          # Read final sync count
          synced_count=$(cat /tmp/sync_count)
          echo "Total files synced: $synced_count"
          
          # Step: Find and remove orphaned files
          echo ""
          echo "Checking for orphaned files..."
          orphaned_count=0
          > /tmp/orphaned_files.txt
          
          for source_dir in $CLAUDE_DIRS; do
            if [ -d ".temp/target_repo/$source_dir" ]; then
              # Find all existing files in target
              find ".temp/target_repo/$source_dir" -type f | while read -r existing_file; do
                rel_path=${existing_file#.temp/target_repo/}
                
                # Check if this file is in our sync manifest
                if ! grep -q "^$rel_path$" /tmp/synced_files_manifest.txt; then
                  echo "$existing_file" >> /tmp/orphaned_files.txt
                fi
              done
            fi
          done
          
          # Count and process orphaned files
          orphaned_count=$(wc -l < /tmp/orphaned_files.txt 2>/dev/null || echo "0")
          if [ $orphaned_count -gt 0 ]; then
            echo "Found $orphaned_count orphaned files"
            
            # Safety check: Don't delete too many files at once
            if [ $orphaned_count -gt ${{ env.MAX_DELETION_THRESHOLD }} ]; then
              echo "⚠️ WARNING: Would delete $orphaned_count files, which exceeds safety threshold of ${{ env.MAX_DELETION_THRESHOLD }}"
              echo "Orphaned files that would be deleted:"
              cat /tmp/orphaned_files.txt | while read -r file; do
                echo "  - ${file#.temp/target_repo/}"
              done
              echo "Skipping deletion for safety. Manual review required."
            else
              if [ "${{ env.DRY_RUN }}" = "true" ]; then
                echo "DRY RUN MODE: Would remove the following orphaned files:"
                while IFS= read -r orphaned_file; do
                  [ -z "$orphaned_file" ] && continue
                  echo "  - ${orphaned_file#.temp/target_repo/}"
                done < /tmp/orphaned_files.txt
              else
                echo "Removing orphaned files..."
                while IFS= read -r orphaned_file; do
                  [ -z "$orphaned_file" ] && continue
                  if [ -f "$orphaned_file" ]; then
                    rm "$orphaned_file"
                    echo "  ✓ Removed: ${orphaned_file#.temp/target_repo/}"
                  fi
                done < /tmp/orphaned_files.txt
              fi
            fi
          else
            echo "No orphaned files found"
          fi
          
          # Clean up empty directories
          echo "Cleaning up empty directories..."
          for source_dir in $CLAUDE_DIRS; do
            if [ -d ".temp/target_repo/$source_dir" ]; then
              find ".temp/target_repo/$source_dir" -type d -empty -delete 2>/dev/null || true
            fi
          done
          
          # Cleanup temp files
          rm -f /tmp/sync_count /tmp/synced_files_manifest.txt /tmp/orphaned_files.txt

      - name: Commit and push to target repo
        if: steps.verify-checkout.outputs.checkout_success == 'true'
        working-directory: .temp/target_repo
        run: |
          git config user.name "${{ env.BOT_NAME }}"
          git config user.email "${{ env.BOT_EMAIL }}"
          
          # Check what files exist before attempting to add
          echo "Checking for Claude directories to add:"
          for dir in .claude/agents/corthos .claude/commands/corthos .claude/hooks/corthos; do
            if [ -d "$dir" ]; then
              echo "  ✓ Found: $dir"
              # Add with force to override gitignore
              git add -A -f "$dir"
            else
              echo "  ✗ Not found: $dir"
            fi
          done
          
          # Also add any .claude directory that exists (in case it's new)
          if [ -d ".claude" ]; then
            echo "Adding entire .claude directory structure"
            git add -A -f .claude/
          fi
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit in ${{ matrix.repo }}"
          else
            git commit -m "Sync Claude tools from ${{ env.CODEX_REPO_NAME }} - Automated sync of Claude agents, commands, and hooks from central Codex repository"
            git push
            echo "Successfully pushed updates to ${{ matrix.repo }}"
          fi